/**
 * TypeScript wrapper for Vector Database with IndexedDB persistence
 *
 * This provides a high-level API for vector operations with:
 * - WASM-accelerated similarity search
 * - IndexedDB persistence
 * - Automatic serialization/deserialization
 */

// Import WASM module (will be generated by wasm-pack)
// Adjust the path based on your build target (bundler/web/nodejs)
import type {
  VectorDB as WasmVectorDB,
} from './pkg/bundler/idbvec'

export interface SearchResult {
  id: string
  distance: number
  metadata?: Record<string, string>
}

export interface VectorRecord {
  id: string
  vector: Float32Array
  metadata?: Record<string, string>
}

export interface GetResult {
  id: string
  vector: Float32Array
  metadata?: Record<string, string>
}

export interface SearchOptions {
  k?: number // Number of results (default: 10)
  ef?: number // Search quality parameter (default: 50)
}

export type DistanceMetric = 'euclidean' | 'cosine' | 'dotproduct'

export interface VectorDBConfig {
  name: string
  dimensions: number
  m?: number // Max connections per layer (default: 16)
  efConstruction?: number // Construction quality (default: 200)
  metric?: DistanceMetric // Distance metric (default: 'euclidean')
}

/**
 * Vector Database with IndexedDB persistence
 */
export class VectorDatabase {
  private wasmDB: WasmVectorDB | null = null
  private idb: IDBDatabase | null = null
  private config: Required<Pick<VectorDBConfig, 'name' | 'dimensions' | 'm' | 'efConstruction'>> & { metric: DistanceMetric }
  private saveTimer: ReturnType<typeof setTimeout> | null = null
  private saveDebounceMs: number = 1000

  constructor(config: VectorDBConfig) {
    this.config = {
      name: config.name,
      dimensions: config.dimensions,
      m: config.m ?? 16,
      efConstruction: config.efConstruction ?? 200,
      metric: config.metric ?? 'euclidean',
    }
  }

  /**
   * Initialize the database (load WASM + IndexedDB)
   */
  async init(): Promise<void> {
    // Load WASM module (auto-initializes on import for bundler target)
    const wasmModule = await import('./pkg/bundler/idbvec')

    // Open IndexedDB
    this.idb = await this.openIndexedDB()

    // Try to restore from IndexedDB
    const saved = await this.loadFromIndexedDB()
    if (saved) {
      this.wasmDB = wasmModule.VectorDB.deserialize(saved)
    } else {
      this.wasmDB = new wasmModule.VectorDB(
        this.config.dimensions,
        this.config.m,
        this.config.efConstruction,
        this.config.metric
      )
    }
  }

  /**
   * Insert a vector into the database
   */
  async insert(
    id: string,
    vector: Float32Array,
    metadata?: Record<string, string>
  ): Promise<void> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    this.wasmDB.insert(id, vector, metadata ?? null)

    // Debounced persistence
    this.debounceSave()
  }

  /**
   * Batch insert multiple vectors
   */
  async insertBatch(records: VectorRecord[]): Promise<void> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    for (const record of records) {
      this.wasmDB.insert(record.id, record.vector, record.metadata ?? null)
    }

    await this.saveToIndexedDB()
  }

  /**
   * Search for nearest neighbors
   */
  async search(
    query: Float32Array,
    options: SearchOptions = {}
  ): Promise<SearchResult[]> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    const k = options.k ?? 10
    const ef = options.ef ?? 50

    const results = this.wasmDB.search(query, k, ef)

    return results as SearchResult[]
  }

  /**
   * Get a vector and its metadata by ID
   */
  async get(id: string): Promise<GetResult | null> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    const result = this.wasmDB.get(id)
    if (result === null || result === undefined) return null

    return result as GetResult
  }

  /**
   * Check if a vector exists by ID
   */
  has(id: string): boolean {
    if (!this.wasmDB) throw new Error('Database not initialized')
    return this.wasmDB.has(id)
  }

  /**
   * List all vector IDs
   */
  listIds(): string[] {
    if (!this.wasmDB) throw new Error('Database not initialized')
    return this.wasmDB.list_ids() as string[]
  }

  /**
   * Delete a vector by ID
   */
  async delete(id: string): Promise<boolean> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    const deleted = this.wasmDB.delete(id)

    if (deleted) {
      this.debounceSave()
    }

    return deleted
  }

  /**
   * Delete multiple vectors by ID
   */
  async deleteBatch(ids: string[]): Promise<number> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    const count = this.wasmDB.delete_batch(ids)

    if (count > 0) {
      await this.saveToIndexedDB()
    }

    return count
  }

  /**
   * Get total number of vectors
   */
  size(): number {
    if (!this.wasmDB) throw new Error('Database not initialized')
    return this.wasmDB.size()
  }

  /**
   * Clear all data
   */
  async clear(): Promise<void> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    const wasmModule = await import('./pkg/bundler/idbvec')
    this.wasmDB.free()
    this.wasmDB = new wasmModule.VectorDB(
      this.config.dimensions,
      this.config.m,
      this.config.efConstruction,
      this.config.metric
    )

    await this.saveToIndexedDB()
  }

  /**
   * Export the database state as a JSON string
   */
  exportData(): string {
    if (!this.wasmDB) throw new Error('Database not initialized')
    return this.wasmDB.serialize()
  }

  /**
   * Import database state from a JSON string
   */
  async importData(json: string): Promise<void> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    const wasmModule = await import('./pkg/bundler/idbvec')
    this.wasmDB.free()
    this.wasmDB = wasmModule.VectorDB.deserialize(json)

    await this.saveToIndexedDB()
  }

  /**
   * Flush any pending saves to IndexedDB immediately
   */
  async flush(): Promise<void> {
    if (this.saveTimer) {
      clearTimeout(this.saveTimer)
      this.saveTimer = null
    }
    await this.saveToIndexedDB()
  }

  /**
   * Destroy the database completely (deletes IndexedDB)
   */
  async destroy(): Promise<void> {
    this.close()

    return new Promise((resolve, reject) => {
      const request = indexedDB.deleteDatabase(this.config.name)
      request.onerror = () => reject(request.error)
      request.onsuccess = () => resolve()
    })
  }

  /**
   * Open IndexedDB connection
   */
  private openIndexedDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.config.name, 1)

      request.onerror = () => reject(request.error)
      request.onsuccess = () => {
        const db = request.result

        // CRITICAL: Handle versionchange event to auto-close when database is being deleted
        // This prevents "blocked" errors when trying to delete the database
        db.onversionchange = () => {
          db.close()
          this.idb = null
        }

        resolve(db)
      }

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result
        if (!db.objectStoreNames.contains('vectordb')) {
          db.createObjectStore('vectordb')
        }
      }
    })
  }

  /**
   * Debounced save to IndexedDB
   */
  private debounceSave(): void {
    if (this.saveTimer) {
      clearTimeout(this.saveTimer)
    }
    this.saveTimer = setTimeout(() => {
      this.saveTimer = null
      this.saveToIndexedDB()
    }, this.saveDebounceMs)
  }

  /**
   * Save WASM state to IndexedDB
   */
  private async saveToIndexedDB(): Promise<void> {
    if (!this.idb || !this.wasmDB) return

    const serialized = this.wasmDB.serialize()

    return new Promise((resolve, reject) => {
      const tx = this.idb!.transaction('vectordb', 'readwrite')
      const store = tx.objectStore('vectordb')
      const request = store.put(serialized, 'state')

      request.onerror = () => reject(request.error)
      request.onsuccess = () => resolve()
    })
  }

  /**
   * Load WASM state from IndexedDB
   */
  private async loadFromIndexedDB(): Promise<string | null> {
    if (!this.idb) return null

    return new Promise((resolve, reject) => {
      const tx = this.idb!.transaction('vectordb', 'readonly')
      const store = tx.objectStore('vectordb')
      const request = store.get('state')

      request.onerror = () => reject(request.error)
      request.onsuccess = () => {
        const result = request.result
        resolve(result ?? null)
      }
    })
  }

  /**
   * Close the database
   */
  close(): void {
    // Flush pending saves
    if (this.saveTimer) {
      clearTimeout(this.saveTimer)
      this.saveTimer = null
    }

    if (this.idb) {
      this.idb.close()
      this.idb = null
    }
    if (this.wasmDB) {
      this.wasmDB.free()
      this.wasmDB = null
    }
  }

  /**
   * Support for explicit resource management (using syntax)
   */
  [Symbol.dispose](): void {
    this.close()
  }
}

/**
 * Standalone distance functions
 */
export async function cosineSimilarity(
  a: Float32Array,
  b: Float32Array
): Promise<number> {
  const wasmModule = await import('./pkg/bundler/idbvec')
  return wasmModule.cosine_similarity(a, b)
}

export async function euclideanDistance(
  a: Float32Array,
  b: Float32Array
): Promise<number> {
  const wasmModule = await import('./pkg/bundler/idbvec')
  return wasmModule.euclidean_distance(a, b)
}

export async function dotProduct(
  a: Float32Array,
  b: Float32Array
): Promise<number> {
  const wasmModule = await import('./pkg/bundler/idbvec')
  return wasmModule.dot_product(a, b)
}
