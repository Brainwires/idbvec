/**
 * TypeScript wrapper for Vector Database with IndexedDB persistence
 *
 * This provides a high-level API for vector operations with:
 * - WASM-accelerated similarity search
 * - IndexedDB persistence
 * - Automatic serialization/deserialization
 */

// Import WASM module (will be generated by wasm-pack)
// Adjust the path based on your build target (bundler/web/nodejs)
import type {
  VectorDB as WasmVectorDB,
} from './pkg/bundler/idbvec'

export interface SearchResult {
  id: string
  score: number
  metadata?: Record<string, string>
}

export interface VectorRecord {
  id: string
  vector: Float32Array
  metadata?: Record<string, string>
}

export interface SearchOptions {
  k?: number // Number of results (default: 10)
  ef?: number // Search quality parameter (default: 50)
}

export interface VectorDBConfig {
  name: string
  dimensions: number
  m?: number // Max connections per layer (default: 16)
  efConstruction?: number // Construction quality (default: 200)
}

/**
 * Vector Database with IndexedDB persistence
 */
export class VectorDatabase {
  private wasmDB: WasmVectorDB | null = null
  private idb: IDBDatabase | null = null
  private config: Required<VectorDBConfig>

  constructor(config: VectorDBConfig) {
    this.config = {
      name: config.name,
      dimensions: config.dimensions,
      m: config.m ?? 16,
      efConstruction: config.efConstruction ?? 200,
    }
  }

  /**
   * Initialize the database (load WASM + IndexedDB)
   */
  async init(): Promise<void> {
    // Load WASM module (auto-initializes on import for bundler target)
    const wasmModule = await import('./pkg/bundler/idbvec')

    // Open IndexedDB
    this.idb = await this.openIndexedDB()

    // Try to restore from IndexedDB
    const saved = await this.loadFromIndexedDB()
    if (saved) {
      this.wasmDB = wasmModule.VectorDB.deserialize(saved)
      // console.log('Restored VectorDB from IndexedDB')
    } else {
      this.wasmDB = new wasmModule.VectorDB(
        this.config.dimensions,
        this.config.m,
        this.config.efConstruction
      )
      // console.log('Created new VectorDB')
    }
  }

  /**
   * Insert a vector into the database
   */
  async insert(
    id: string,
    vector: Float32Array,
    metadata?: Record<string, string>
  ): Promise<void> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    this.wasmDB.insert(id, vector, metadata ?? null)

    // Persist to IndexedDB
    await this.saveToIndexedDB()
  }

  /**
   * Batch insert multiple vectors
   */
  async insertBatch(records: VectorRecord[]): Promise<void> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    for (const record of records) {
      // console.log('üîç Inserting to WASM:', {
      //   id: record.id,
      //   vectorLength: record.vector.length,
      //   metadata: record.metadata,
      //   metadataType: typeof record.metadata,
      //   metadataKeys: record.metadata ? Object.keys(record.metadata) : null
      // })
      this.wasmDB.insert(record.id, record.vector, record.metadata ?? null)
    }

    await this.saveToIndexedDB()
  }

  /**
   * Search for nearest neighbors
   */
  async search(
    query: Float32Array,
    options: SearchOptions = {}
  ): Promise<SearchResult[]> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    const k = options.k ?? 10
    const ef = options.ef ?? 50

    const results = this.wasmDB.search(query, k, ef)

    return results as SearchResult[]
  }

  /**
   * Delete a vector by ID
   */
  async delete(id: string): Promise<boolean> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    const deleted = this.wasmDB.delete(id)

    if (deleted) {
      await this.saveToIndexedDB()
    }

    return deleted
  }

  /**
   * Get total number of vectors
   */
  size(): number {
    if (!this.wasmDB) throw new Error('Database not initialized')
    return this.wasmDB.size()
  }

  /**
   * Clear all data
   */
  async clear(): Promise<void> {
    if (!this.wasmDB) throw new Error('Database not initialized')

    const wasmModule = await import('./pkg/bundler/idbvec')
    this.wasmDB = new wasmModule.VectorDB(
      this.config.dimensions,
      this.config.m,
      this.config.efConstruction
    )

    await this.saveToIndexedDB()
  }

  /**
   * Open IndexedDB connection
   */
  private openIndexedDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.config.name, 1)

      request.onerror = () => reject(request.error)
      request.onsuccess = () => {
        const db = request.result

        // CRITICAL: Handle versionchange event to auto-close when database is being deleted
        // This prevents "blocked" errors when trying to delete the database
        db.onversionchange = () => {
          // console.log(`üîí VectorDB "${this.config.name}" received versionchange event - closing connection`)
          db.close()
          this.idb = null
        }

        resolve(db)
      }

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result
        if (!db.objectStoreNames.contains('vectordb')) {
          db.createObjectStore('vectordb')
        }
      }
    })
  }

  /**
   * Save WASM state to IndexedDB
   */
  private async saveToIndexedDB(): Promise<void> {
    if (!this.idb || !this.wasmDB) return

    const serialized = this.wasmDB.serialize()

    return new Promise((resolve, reject) => {
      const tx = this.idb!.transaction('vectordb', 'readwrite')
      const store = tx.objectStore('vectordb')
      const request = store.put(serialized, 'state')

      request.onerror = () => reject(request.error)
      request.onsuccess = () => resolve()
    })
  }

  /**
   * Load WASM state from IndexedDB
   */
  private async loadFromIndexedDB(): Promise<string | null> {
    if (!this.idb) return null

    return new Promise((resolve, reject) => {
      const tx = this.idb!.transaction('vectordb', 'readonly')
      const store = tx.objectStore('vectordb')
      const request = store.get('state')

      request.onerror = () => reject(request.error)
      request.onsuccess = () => {
        const result = request.result
        resolve(result ?? null)
      }
    })
  }

  /**
   * Close the database
   */
  close(): void {
    if (this.idb) {
      this.idb.close()
      this.idb = null
    }
    this.wasmDB = null
  }
}

/**
 * Standalone distance functions
 */
export async function cosineSimilarity(
  a: Float32Array,
  b: Float32Array
): Promise<number> {
  const wasmModule = await import('./pkg/bundler/idbvec')
  return wasmModule.cosine_similarity(a, b)
}

export async function euclideanDistance(
  a: Float32Array,
  b: Float32Array
): Promise<number> {
  const wasmModule = await import('./pkg/bundler/idbvec')
  return wasmModule.euclidean_distance(a, b)
}

export async function dotProduct(
  a: Float32Array,
  b: Float32Array
): Promise<number> {
  const wasmModule = await import('./pkg/bundler/idbvec')
  return wasmModule.dot_product(a, b)
}
